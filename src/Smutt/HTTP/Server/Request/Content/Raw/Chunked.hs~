{-# LANGUAGE OverloadedStrings #-}

module Smutt.HTTP.Server.Request.Content.Raw.Chunked  where


import Data.IORef
import Control.Monad.Except
import Control.Concurrent.MVar 
    
import Data.ByteString.Lazy (ByteString)
import qualified Data.ByteString.Lazy as BL
import qualified Data.ByteString.Lazy.Char8 as BLC

import Network.BufferedSocket (BufferedSocket)
import qualified Network.BufferedSocket as BS


import Smutt.HTTP.Server.Request (Request, ReadState)
import qualified Smutt.HTTP.Server.Request as Req

import Data.Char 
     
import qualified Smutt.Util.Hex as Hex

import Smutt.HTTP.Server.Request.Content.Error

import qualified Smutt.HTTP.Header.Reader as Header
import qualified Smutt.HTTP.Header (Header)

{-
All chunk headers should be read as soon as a read notices that there are no more bytes left in the current chunk.
-}

-- | Reads part of the request 
readPart :: BufferedSocket -> MVar ReadState -> Int -> ExceptT Error IO (Int, ByteString)
readPart bSock rsMVar readLength = do
  readState <- takeMVar rsMVar
  let currentChunkSize = Req.currentChunkSize readState
  (message, readState, bytesRead) <-  readPartLoop bSocket readState readLength
  liftIO $ putMVar rsMVar readState
  return (bytesRead, message)
  
       

readPartLoop :: BufferedSocket -> ReadState -> Int -> ExceptT Error IO (Int, ByteString, ReadState)
readPartLoop bSock readState readLength
  | readLength == 0 = return (0, "", readState)
  | readLength < bytesLeft = readPartOfChunk bSock readState readLength >>= \ (str,rs) -> return (readLength, str, rs)
  | otherwise = do
      (message, firstReadState) <- readChunk bSock readState readLength
      (restLen, nextMessage, secondReadState) <- readPartLoop bSock firstReadState (readLength - bytesLeft)
      return (bytesLeft + restLen, message <> nextMessage, secondReadState)

  where
    bytesLeft = Req.chunkBytesLeft readState 

readPartOfChunk :: BufferedSocket -> ReadState -> Int -> ExceptT Error IO (ByteString, ReadState)
readPartOfChunk bSock readState readLength  = do
  message <- liftIO $ BS.readString bSock readLength
  return (message, readState{Req.chunkedBytesLeft = Req.chunkedBytesLeft - readLength})
  

-- | Reads all data available in the request 
readAll :: BufferedSocket -> MVar ReadState -> ExceptT Error IO ByteString
readAll bSock rsMVar = do
  readState <- takeMVar rsMVar
  
  when (Req.chunkedEOF readState) $ liftIO (putMVar rsMVar readState) >> throwError EOF
  
  (message, newReadState) <- readAllLoop bSock readState `catchError` (\e -> putMVar rsMVar readState >> throwError e)
  liftIO $ putMVar rsMVar newReadState
  return message


-- Reads all bytes until EOF is reached
readAllLoop :: BufferedSocket -> ReadState -> ExceptT Error IO (ByteString, ReadState)
readAllLoop bSocket readState  
  | Req.chunkedEOF readState =  return ("", readState) 
  | otherwise = do
      (message, firstReadState) <- readChunk bSock readState
      (nextMessage, secondReadState) <- readAllLoop bSock firstReadState
      return (message <> nextMessage, secondReadState)

-- | Reads an entire chunk from start to end.
readChunk :: BufferedSocket ->  ReadSate ->  ExceptT Error IO (ByteString, ReadState)
readChunk bSock readState = do
  chunkMessage <- liftIO $ BS.readString bSocket bytesLeft
  nextChunkSize <- readChunkLength bSock 1024
  maybeTrailer <- if nextChunkSize == 0
                  then readTrailer bSock
                  else return $ Nothing

  let newReadState = readState{
        Req.chunkedTotalRead = Req.chunkedTotalRead readState + chunkBytesLeft 
        Req.chunkbytesLeft   = nextChunkSize
        Req.chunkedEOF       = nextChunkSize == 0
        Req.trailer          = maybeTrailer
        }
  return (chunkMessage, newReadState)
  where
    cbytesLeft = Req.chunkBytesLeft readState 
    
 


-- May not actually read the header of the chunked message if there's bytes left in the current mssage
readChunkedHead :: BufferedSocket -> ReadState -> ExceptT ContentError IO ReadState
readChunkedHead bSock readState
  | Req.chunkedEOF readState = throwError EOF
  | currentChunkBytesLeft > 0 = return readState 
  | otherwise = do
      chunkSize <- readChunkLength bSock 512
      if cunkSize == 0
        then readTrailer chunkedState
        else return chunkedState{Req.chunkBytesLeft = n}

    where
      chunkBytesLeft = Req.currentChunk readState 


type ChunkSizeRowMaxLength = Int 
-- | Reads the length of a chunk. Limits the length of  
readChunkLength :: BufferedSocket -> ChunkSizeRowMaxLength ->  ExceptT ContentError IO Int
readChunkLength bSock rowMaxSize = do
  maybeLengthLineStr <- liftIO $ BS.readToSequenceLimited bSock "\cr\lf" rowMaxSize
  case maybeLengthLineStr of
    Nothing ->  throwError ChunkSizeStingTooLarge
    Just lengthLineStr -> let 
      lengthStr = BLC.takeWhile (/=';') $ BLC.dropWhile isSpace lengthLineStr
      maybeLength =  Hex.fromIntegral lengthStr
      in case maybeLength of
        Nothing -> throwError InvalidEncoding
        Just chunkLength -> maybeHexStr
    

-- Note to self the temp limit needs to be user decided
readTrailer :: BufferedSocket -> ReadState -> ExceptT Error  IO Header
readTrailer bSock readState =  HS.read tempLimit tempLimit bSocket
  where
    tempLimit = 1024
  




nonChunkedBodyErrorMsg :: String
nonChunkedBodyErrorMsg = "Tried to read chunked data from non chunked request"
