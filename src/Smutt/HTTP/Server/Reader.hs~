{-# LANGUAGE OverloadedLists, OverloadedStrings #-}
module Smutt.HTTP.Server.Reader where


import Control.Monad.Trans.Except

import Smutt.HTTP.Method as Method
import Smutt.HTTP.URI as URI
import Smutt.HTTP.Version as Version
import Smutt.HTTP.Header.Header as Header

import Smutt.HTTP.Header.RequestLine (RequestLine)
import Smutt.HTTP.Header.RequestLine as ReqLine

import Smutt.HTTP.Server.Settings
import Network.BufferedSocket (BufferedSocket)
import qualified Network.BufferedSocket as BS

import Smutt.Util.ByteString
import qualified Data.ByteString.Lazy as BL
import qualified Data.ByteString.Lazy as BL (readInt)
import qualified Data.ByteString as B

import qualified Smutt.Util.Ascii as Ascii

import Data.Maybe

import Data.Set
import qualified Data.Set as Set

import Data.IORef

import Smutt.HTTP.Error



supportedHTTPVersions:: Set Verion
supportedHTTPVersions = [HTTP 1 0, HTTP 1 1]

read :: BufferedSocket -> ServerSettings -> ExceptT ReaderError IO Request
read bSocket settings = do
  requestLineStr <- ExceptT $ maybe (Left HeaderTooLarge) Right <$> BS.readToSequenceLimited bSocket crlf (maxRequstLineLength setting)

  (RequestLine method uri version) <- lift $ ReqLine.fromString requestLineStr
  let isHTTP11 = version == HTTP 1 1
  when isHTTP11 send100Continue

  headers <- Header.read (maxHeaderLineLength settings) (maxHeaderLength setting) bSocket
  bytesReadCounter <- lift newIORef

  when (Set.notMember version supportedHTTPVersions) (throwError HTTPVersionNotSupported)
  when (isHTTP11 && isNothing (lookup Host headers)) (throwError $ BadRequest "Missing Host")

  let request = Request method uri version headers "" bytesReadCounter bSocket
  if method == POST then prepareBody request else return request


send100Continue :: BufferedSocket -> IO ()
send100Continue bSocket = BS.send bSocket "HTTP/1.1 100 continue\r\n" >> BS.flush BufferedSocket




contentLenghtBodyReader ::  Request BL.ByteString -> ExceptT ReaderError IO (Request BL.ByteString)
contentLenghtBodyReader request = do
  contentLengthField <- ExceptT $ maybe (Left LengthRequired) Right maybeContentLengthField
  contentLength <- ExeptT $ maybe (BadRequest "Invalid Content-Length") Right $ fst <$> BL.readInt $ BL.dropWhile Ascii.isSpace contentLenghtField
let body = "" : [ ]

  contentLenghtField <- maybeContentLengthField
  where
    maybeContentLengthField =  lookup ContentLength (headers request)



makeContentLengthBodyReader :: Int -> Request BL.ByteString -> IO BL.ByteString
makeContentLengthBodyReader totalLength = do
  bytesAllreadyRead <- readIORef $ bodyBytesRead request
